/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-sortablejs";
exports.ids = ["vendor-chunks/react-sortablejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-sortablejs/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-sortablejs/dist/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var $8zHUo$sortablejs = __webpack_require__(/*! sortablejs */ \"(ssr)/./node_modules/sortablejs/modular/sortable.esm.js\");\nvar $8zHUo$classnames = __webpack_require__(/*! classnames */ \"(ssr)/./node_modules/classnames/index.js\");\nvar $8zHUo$react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar $8zHUo$tinyinvariant = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\");\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n\n  return dest;\n}\n\n$parcel$export(module.exports, \"Sortable\", () => $882b6d93070905b3$re_export$Sortable);\n$parcel$export(module.exports, \"Direction\", () => $882b6d93070905b3$re_export$Direction);\n$parcel$export(module.exports, \"DOMRect\", () => $882b6d93070905b3$re_export$DOMRect);\n$parcel$export(module.exports, \"GroupOptions\", () => $882b6d93070905b3$re_export$GroupOptions);\n$parcel$export(module.exports, \"MoveEvent\", () => $882b6d93070905b3$re_export$MoveEvent);\n$parcel$export(module.exports, \"Options\", () => $882b6d93070905b3$re_export$Options);\n$parcel$export(module.exports, \"PullResult\", () => $882b6d93070905b3$re_export$PullResult);\n$parcel$export(module.exports, \"PutResult\", () => $882b6d93070905b3$re_export$PutResult);\n$parcel$export(module.exports, \"SortableEvent\", () => $882b6d93070905b3$re_export$SortableEvent);\n$parcel$export(module.exports, \"SortableOptions\", () => $882b6d93070905b3$re_export$SortableOptions);\n$parcel$export(module.exports, \"Utils\", () => $882b6d93070905b3$re_export$Utils);\n$parcel$export(module.exports, \"ReactSortable\", () => $7fe8e3ea572bda7a$export$11bbed9ee0012c13);\n\n\n\n\n\nfunction $eb03e74f8f7db1f3$export$1d0aa160432dfea5(node) {\n    if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\nfunction $eb03e74f8f7db1f3$export$6d240faa51aa562f(parent, newChild, index) {\n    const refChild = parent.children[index] || null;\n    parent.insertBefore(newChild, refChild);\n}\nfunction $eb03e74f8f7db1f3$export$d7d742816c28cf91(customs) {\n    $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n    $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n}\nfunction $eb03e74f8f7db1f3$export$77f49a256021c8de(customs) {\n    customs.forEach((curr)=>$eb03e74f8f7db1f3$export$1d0aa160432dfea5(curr.element));\n}\nfunction $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs) {\n    customs.forEach((curr)=>{\n        $eb03e74f8f7db1f3$export$6d240faa51aa562f(curr.parentElement, curr.element, curr.oldIndex);\n    });\n}\nfunction $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list) {\n    const mode = $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt);\n    const parentElement = {\n        parentElement: evt.from\n    };\n    let custom = [];\n    switch(mode){\n        case \"normal\":\n            /* eslint-disable */ const item = {\n                element: evt.item,\n                newIndex: evt.newIndex,\n                oldIndex: evt.oldIndex,\n                parentElement: evt.from\n            };\n            custom = [\n                item\n            ];\n            break;\n        case \"swap\":\n            const drag = {\n                element: evt.item,\n                oldIndex: evt.oldIndex,\n                newIndex: evt.newIndex,\n                ...parentElement\n            };\n            const swap = {\n                element: evt.swapItem,\n                oldIndex: evt.newIndex,\n                newIndex: evt.oldIndex,\n                ...parentElement\n            };\n            custom = [\n                drag,\n                swap\n            ];\n            break;\n        case \"multidrag\":\n            custom = evt.oldIndicies.map((curr, index)=>({\n                    element: curr.multiDragElement,\n                    oldIndex: curr.index,\n                    newIndex: evt.newIndicies[index].index,\n                    ...parentElement\n                }));\n            break;\n    }\n    /* eslint-enable */ const customs = $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(custom, list);\n    return customs;\n}\nfunction $eb03e74f8f7db1f3$export$c25cf8080bd305ec(normalized, list) {\n    const a = $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list);\n    const b = $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, a);\n    return b;\n}\nfunction $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list) {\n    const newList = [\n        ...list\n    ];\n    normalized.concat().reverse().forEach((curr)=>newList.splice(curr.oldIndex, 1));\n    return newList;\n}\nfunction $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, list, evt, clone) {\n    const newList = [\n        ...list\n    ];\n    normalized.forEach((curr)=>{\n        const newItem = clone && evt && clone(curr.item, evt);\n        newList.splice(curr.newIndex, 0, newItem || curr.item);\n    });\n    return newList;\n}\nfunction $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt) {\n    if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n    if (evt.swapItem) return \"swap\";\n    return \"normal\";\n}\nfunction $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(inputs, list) {\n    const normalized = inputs.map((curr)=>({\n            ...curr,\n            item: list[curr.oldIndex]\n        })).sort((a, b)=>a.oldIndex - b.oldIndex);\n    return normalized;\n}\nfunction $eb03e74f8f7db1f3$export$7553c81e62e31b7e(props) {\n    /* eslint-disable */ const { list: // react sortable props\n    list , setList: setList , children: children , tag: tag , style: style , className: className , clone: clone , onAdd: // sortable options that have methods we want to overwrite\n    onAdd , onChange: onChange , onChoose: onChoose , onClone: onClone , onEnd: onEnd , onFilter: onFilter , onRemove: onRemove , onSort: onSort , onStart: onStart , onUnchoose: onUnchoose , onUpdate: onUpdate , onMove: onMove , onSpill: onSpill , onSelect: onSelect , onDeselect: onDeselect , ...options } = props;\n    /* eslint-enable */ return options;\n}\n\n\n/** Holds a global reference for which react element is being dragged */ // @todo - use context to manage this. How does one use 2 different providers?\nconst $7fe8e3ea572bda7a$var$store = {\n    dragging: null\n};\nclass $7fe8e3ea572bda7a$export$11bbed9ee0012c13 extends (0, $8zHUo$react.Component) {\n    /* eslint-disable-next-line */ static defaultProps = {\n        clone: (item)=>item\n    };\n    constructor(props){\n        super(props);\n        // @todo forward ref this component\n        this.ref = /*#__PURE__*/ (0, $8zHUo$react.createRef)();\n        // make all state false because we can't change sortable unless a mouse gesture is made.\n        const newList = [\n            ...props.list\n        ].map((item)=>Object.assign(item, {\n                chosen: false,\n                selected: false\n            }));\n        props.setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n        (0, ($parcel$interopDefault($8zHUo$tinyinvariant)))(//@ts-expect-error: Doesn't exist. Will deprecate soon.\n        !props.plugins, `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `);\n    }\n    componentDidMount() {\n        if (this.ref.current === null) return;\n        const newOptions = this.makeOptions();\n        (0, ($parcel$interopDefault($8zHUo$sortablejs))).create(this.ref.current, newOptions);\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.disabled !== this.props.disabled && this.sortable) this.sortable.option(\"disabled\", this.props.disabled);\n    }\n    render() {\n        const { tag: tag , style: style , className: className , id: id  } = this.props;\n        const classicProps = {\n            style: style,\n            className: className,\n            id: id\n        };\n        // if no tag, default to a `div` element.\n        const newTag = !tag || tag === null ? \"div\" : tag;\n        return /*#__PURE__*/ (0, $8zHUo$react.createElement)(newTag, {\n            // @todo - find a way (perhaps with the callback) to allow AntD components to work\n            ref: this.ref,\n            ...classicProps\n        }, this.getChildren());\n    }\n    getChildren() {\n        const { children: children , dataIdAttr: dataIdAttr , selectedClass: selectedClass = \"sortable-selected\" , chosenClass: chosenClass = \"sortable-chosen\" , dragClass: /* eslint-disable */ dragClass = \"sortable-drag\" , fallbackClass: fallbackClass = \"sortable-falback\" , ghostClass: ghostClass = \"sortable-ghost\" , swapClass: swapClass = \"sortable-swap-highlight\" , filter: /* eslint-enable */ filter = \"sortable-filter\" , list: list ,  } = this.props;\n        // if no children, don't do anything.\n        if (!children || children == null) return null;\n        const dataid = dataIdAttr || \"data-id\";\n        /* eslint-disable-next-line */ return (0, $8zHUo$react.Children).map(children, (child, index)=>{\n            if (child === undefined) return undefined;\n            const item = list[index] || {};\n            const { className: prevClassName  } = child.props;\n            // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n            const filtered = typeof filter === \"string\" && {\n                [filter.replace(\".\", \"\")]: !!item.filtered\n            };\n            const className = (0, ($parcel$interopDefault($8zHUo$classnames)))(prevClassName, {\n                [selectedClass]: item.selected,\n                [chosenClass]: item.chosen,\n                ...filtered\n            });\n            return /*#__PURE__*/ (0, $8zHUo$react.cloneElement)(child, {\n                [dataid]: child.key,\n                className: className\n            });\n        });\n    }\n    /** Appends the `sortable` property to this component */ get sortable() {\n        const el = this.ref.current;\n        if (el === null) return null;\n        const key = Object.keys(el).find((k)=>k.includes(\"Sortable\"));\n        if (!key) return null;\n        //@ts-expect-error: fix me.\n        return el[key];\n    }\n    /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */ makeOptions() {\n        const DOMHandlers = [\n            \"onAdd\",\n            \"onChoose\",\n            \"onDeselect\",\n            \"onEnd\",\n            \"onRemove\",\n            \"onSelect\",\n            \"onSpill\",\n            \"onStart\",\n            \"onUnchoose\",\n            \"onUpdate\", \n        ];\n        const NonDOMHandlers = [\n            \"onChange\",\n            \"onClone\",\n            \"onFilter\",\n            \"onSort\", \n        ];\n        const newOptions = (0, $eb03e74f8f7db1f3$export$7553c81e62e31b7e)(this.props);\n        DOMHandlers.forEach((name)=>newOptions[name] = this.prepareOnHandlerPropAndDOM(name));\n        NonDOMHandlers.forEach((name)=>newOptions[name] = this.prepareOnHandlerProp(name));\n        /** onMove has 2 arguments and needs to be handled seperately. */ const onMove1 = (evt, originalEvt)=>{\n            const { onMove: onMove  } = this.props;\n            const defaultValue = evt.willInsertAfter || -1;\n            if (!onMove) return defaultValue;\n            const result = onMove(evt, originalEvt, this.sortable, $7fe8e3ea572bda7a$var$store);\n            if (typeof result === \"undefined\") return false;\n            return result;\n        };\n        return {\n            ...newOptions,\n            onMove: onMove1\n        };\n    }\n    /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */ prepareOnHandlerPropAndDOM(evtName) {\n        return (evt)=>{\n            // call the component prop\n            this.callOnHandlerProp(evt, evtName);\n            // calls state change\n            //@ts-expect-error: until @types multidrag item is in\n            this[evtName](evt);\n        };\n    }\n    /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */ prepareOnHandlerProp(evtName) {\n        return (evt)=>{\n            // call the component prop\n            this.callOnHandlerProp(evt, evtName);\n        };\n    }\n    /** Calls the `props.on[Handler]` function */ callOnHandlerProp(evt, evtName) {\n        const propEvent = this.props[evtName];\n        if (propEvent) propEvent(evt, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n    // SORTABLE DOM HANDLING\n    onAdd(evt) {\n        const { list: list , setList: setList , clone: clone  } = this.props;\n        /* eslint-disable-next-line */ const otherList = [\n            ...$7fe8e3ea572bda7a$var$store.dragging.props.list\n        ];\n        const customs = (0, $eb03e74f8f7db1f3$export$4655efe700f887a)(evt, otherList);\n        (0, $eb03e74f8f7db1f3$export$77f49a256021c8de)(customs);\n        const newList = (0, $eb03e74f8f7db1f3$export$eca851ee65ae17e4)(customs, list, evt, clone).map((item)=>Object.assign(item, {\n                selected: false\n            }));\n        setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n    onRemove(evt) {\n        const { list: list , setList: setList  } = this.props;\n        const mode = (0, $eb03e74f8f7db1f3$export$1fc0f6205829e19c)(evt);\n        const customs = (0, $eb03e74f8f7db1f3$export$4655efe700f887a)(evt, list);\n        (0, $eb03e74f8f7db1f3$export$a6177d5829f70ebc)(customs);\n        let newList = [\n            ...list\n        ];\n        // remove state if not in clone mode. otherwise, keep.\n        if (evt.pullMode !== \"clone\") newList = (0, $eb03e74f8f7db1f3$export$be2da95e6167b0bd)(customs, newList);\n        else {\n            // switch used to get the clone\n            let customClones = customs;\n            switch(mode){\n                case \"multidrag\":\n                    customClones = customs.map((item, index)=>({\n                            ...item,\n                            element: evt.clones[index]\n                        }));\n                    break;\n                case \"normal\":\n                    customClones = customs.map((item)=>({\n                            ...item,\n                            element: evt.clone\n                        }));\n                    break;\n                case \"swap\":\n                default:\n                    (0, ($parcel$interopDefault($8zHUo$tinyinvariant)))(true, `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`);\n            }\n            (0, $eb03e74f8f7db1f3$export$77f49a256021c8de)(customClones);\n            // replace selected items with cloned items\n            customs.forEach((curr)=>{\n                const index = curr.oldIndex;\n                /* eslint-disable-next-line */ const newItem = this.props.clone(curr.item, evt);\n                newList.splice(index, 1, newItem);\n            });\n        }\n        // remove item.selected from list\n        newList = newList.map((item)=>Object.assign(item, {\n                selected: false\n            }));\n        setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n    onUpdate(evt) {\n        const { list: list , setList: setList  } = this.props;\n        const customs = (0, $eb03e74f8f7db1f3$export$4655efe700f887a)(evt, list);\n        (0, $eb03e74f8f7db1f3$export$77f49a256021c8de)(customs);\n        (0, $eb03e74f8f7db1f3$export$a6177d5829f70ebc)(customs);\n        const newList = (0, $eb03e74f8f7db1f3$export$c25cf8080bd305ec)(customs, list);\n        return setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n    onStart() {\n        $7fe8e3ea572bda7a$var$store.dragging = this;\n    }\n    onEnd() {\n        $7fe8e3ea572bda7a$var$store.dragging = null;\n    }\n    onChoose(evt) {\n        const { list: list , setList: setList  } = this.props;\n        const newList = list.map((item, index)=>{\n            let newItem = item;\n            if (index === evt.oldIndex) newItem = Object.assign(item, {\n                chosen: true\n            });\n            return newItem;\n        });\n        setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n    onUnchoose(evt) {\n        const { list: list , setList: setList  } = this.props;\n        const newList = list.map((item, index)=>{\n            let newItem = item;\n            if (index === evt.oldIndex) newItem = Object.assign(newItem, {\n                chosen: false\n            });\n            return newItem;\n        });\n        setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n    onSpill(evt) {\n        const { removeOnSpill: removeOnSpill , revertOnSpill: revertOnSpill  } = this.props;\n        if (removeOnSpill && !revertOnSpill) (0, $eb03e74f8f7db1f3$export$1d0aa160432dfea5)(evt.item);\n    }\n    onSelect(evt) {\n        const { list: list , setList: setList  } = this.props;\n        const newList = list.map((item)=>Object.assign(item, {\n                selected: false\n            }));\n        evt.newIndicies.forEach((curr)=>{\n            const index = curr.index;\n            if (index === -1) {\n                console.log(`\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`);\n                console.log(evt);\n                return;\n            }\n            newList[index].selected = true;\n        });\n        setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n    onDeselect(evt) {\n        const { list: list , setList: setList  } = this.props;\n        const newList = list.map((item)=>Object.assign(item, {\n                selected: false\n            }));\n        evt.newIndicies.forEach((curr)=>{\n            const index = curr.index;\n            if (index === -1) return;\n            newList[index].selected = true;\n        });\n        setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    }\n}\n\n\nvar $faefaad95e5fcca0$exports = {};\n\n\n$parcel$exportWildcard(module.exports, $faefaad95e5fcca0$exports);\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc29ydGFibGVqcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHdCQUF3QixtQkFBTyxDQUFDLDJFQUFZO0FBQzVDLHdCQUF3QixtQkFBTyxDQUFDLDREQUFZO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHdHQUFPO0FBQ2xDLDJCQUEyQixtQkFBTyxDQUFDLHNGQUFnQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQXFEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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dGFibGVqcy9kaXN0L2luZGV4LmpzP2YzZjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICQ4ekhVbyRzb3J0YWJsZWpzID0gcmVxdWlyZShcInNvcnRhYmxlanNcIik7XG52YXIgJDh6SFVvJGNsYXNzbmFtZXMgPSByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKTtcbnZhciAkOHpIVW8kcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgJDh6SFVvJHRpbnlpbnZhcmlhbnQgPSByZXF1aXJlKFwidGlueS1pbnZhcmlhbnRcIik7XG5cbmZ1bmN0aW9uICRwYXJjZWwkaW50ZXJvcERlZmF1bHQoYSkge1xuICByZXR1cm4gYSAmJiBhLl9fZXNNb2R1bGUgPyBhLmRlZmF1bHQgOiBhO1xufVxuZnVuY3Rpb24gJHBhcmNlbCRleHBvcnQoZSwgbiwgdiwgcykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgbiwge2dldDogdiwgc2V0OiBzLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbn1cbmZ1bmN0aW9uICRwYXJjZWwkZXhwb3J0V2lsZGNhcmQoZGVzdCwgc291cmNlKSB7XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnZGVmYXVsdCcgfHwga2V5ID09PSAnX19lc01vZHVsZScgfHwgZGVzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGtleSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZXN0O1xufVxuXG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJTb3J0YWJsZVwiLCAoKSA9PiAkODgyYjZkOTMwNzA5MDViMyRyZV9leHBvcnQkU29ydGFibGUpO1xuJHBhcmNlbCRleHBvcnQobW9kdWxlLmV4cG9ydHMsIFwiRGlyZWN0aW9uXCIsICgpID0+ICQ4ODJiNmQ5MzA3MDkwNWIzJHJlX2V4cG9ydCREaXJlY3Rpb24pO1xuJHBhcmNlbCRleHBvcnQobW9kdWxlLmV4cG9ydHMsIFwiRE9NUmVjdFwiLCAoKSA9PiAkODgyYjZkOTMwNzA5MDViMyRyZV9leHBvcnQkRE9NUmVjdCk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJHcm91cE9wdGlvbnNcIiwgKCkgPT4gJDg4MmI2ZDkzMDcwOTA1YjMkcmVfZXhwb3J0JEdyb3VwT3B0aW9ucyk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJNb3ZlRXZlbnRcIiwgKCkgPT4gJDg4MmI2ZDkzMDcwOTA1YjMkcmVfZXhwb3J0JE1vdmVFdmVudCk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJPcHRpb25zXCIsICgpID0+ICQ4ODJiNmQ5MzA3MDkwNWIzJHJlX2V4cG9ydCRPcHRpb25zKTtcbiRwYXJjZWwkZXhwb3J0KG1vZHVsZS5leHBvcnRzLCBcIlB1bGxSZXN1bHRcIiwgKCkgPT4gJDg4MmI2ZDkzMDcwOTA1YjMkcmVfZXhwb3J0JFB1bGxSZXN1bHQpO1xuJHBhcmNlbCRleHBvcnQobW9kdWxlLmV4cG9ydHMsIFwiUHV0UmVzdWx0XCIsICgpID0+ICQ4ODJiNmQ5MzA3MDkwNWIzJHJlX2V4cG9ydCRQdXRSZXN1bHQpO1xuJHBhcmNlbCRleHBvcnQobW9kdWxlLmV4cG9ydHMsIFwiU29ydGFibGVFdmVudFwiLCAoKSA9PiAkODgyYjZkOTMwNzA5MDViMyRyZV9leHBvcnQkU29ydGFibGVFdmVudCk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJTb3J0YWJsZU9wdGlvbnNcIiwgKCkgPT4gJDg4MmI2ZDkzMDcwOTA1YjMkcmVfZXhwb3J0JFNvcnRhYmxlT3B0aW9ucyk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJVdGlsc1wiLCAoKSA9PiAkODgyYjZkOTMwNzA5MDViMyRyZV9leHBvcnQkVXRpbHMpO1xuJHBhcmNlbCRleHBvcnQobW9kdWxlLmV4cG9ydHMsIFwiUmVhY3RTb3J0YWJsZVwiLCAoKSA9PiAkN2ZlOGUzZWE1NzJiZGE3YSRleHBvcnQkMTFiYmVkOWVlMDAxMmMxMyk7XG5cblxuXG5cblxuZnVuY3Rpb24gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDFkMGFhMTYwNDMyZGZlYTUobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudEVsZW1lbnQgIT09IG51bGwpIG5vZGUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCQ2ZDI0MGZhYTUxYWE1NjJmKHBhcmVudCwgbmV3Q2hpbGQsIGluZGV4KSB7XG4gICAgY29uc3QgcmVmQ2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXhdIHx8IG51bGw7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShuZXdDaGlsZCwgcmVmQ2hpbGQpO1xufVxuZnVuY3Rpb24gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JGQ3ZDc0MjgxNmMyOGNmOTEoY3VzdG9tcykge1xuICAgICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCQ3N2Y0OWEyNTYwMjFjOGRlKGN1c3RvbXMpO1xuICAgICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCRhNjE3N2Q1ODI5ZjcwZWJjKGN1c3RvbXMpO1xufVxuZnVuY3Rpb24gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDc3ZjQ5YTI1NjAyMWM4ZGUoY3VzdG9tcykge1xuICAgIGN1c3RvbXMuZm9yRWFjaCgoY3Vycik9PiRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCQxZDBhYTE2MDQzMmRmZWE1KGN1cnIuZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JGE2MTc3ZDU4MjlmNzBlYmMoY3VzdG9tcykge1xuICAgIGN1c3RvbXMuZm9yRWFjaCgoY3Vycik9PntcbiAgICAgICAgJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDZkMjQwZmFhNTFhYTU2MmYoY3Vyci5wYXJlbnRFbGVtZW50LCBjdXJyLmVsZW1lbnQsIGN1cnIub2xkSW5kZXgpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDQ2NTVlZmU3MDBmODg3YShldnQsIGxpc3QpIHtcbiAgICBjb25zdCBtb2RlID0gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDFmYzBmNjIwNTgyOWUxOWMoZXZ0KTtcbiAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0ge1xuICAgICAgICBwYXJlbnRFbGVtZW50OiBldnQuZnJvbVxuICAgIH07XG4gICAgbGV0IGN1c3RvbSA9IFtdO1xuICAgIHN3aXRjaChtb2RlKXtcbiAgICAgICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi8gY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBldnQuaXRlbSxcbiAgICAgICAgICAgICAgICBuZXdJbmRleDogZXZ0Lm5ld0luZGV4LFxuICAgICAgICAgICAgICAgIG9sZEluZGV4OiBldnQub2xkSW5kZXgsXG4gICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudDogZXZ0LmZyb21cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdXN0b20gPSBbXG4gICAgICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3dhcFwiOlxuICAgICAgICAgICAgY29uc3QgZHJhZyA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBldnQuaXRlbSxcbiAgICAgICAgICAgICAgICBvbGRJbmRleDogZXZ0Lm9sZEluZGV4LFxuICAgICAgICAgICAgICAgIG5ld0luZGV4OiBldnQubmV3SW5kZXgsXG4gICAgICAgICAgICAgICAgLi4ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN3YXAgPSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZXZ0LnN3YXBJdGVtLFxuICAgICAgICAgICAgICAgIG9sZEluZGV4OiBldnQubmV3SW5kZXgsXG4gICAgICAgICAgICAgICAgbmV3SW5kZXg6IGV2dC5vbGRJbmRleCxcbiAgICAgICAgICAgICAgICAuLi5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3VzdG9tID0gW1xuICAgICAgICAgICAgICAgIGRyYWcsXG4gICAgICAgICAgICAgICAgc3dhcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibXVsdGlkcmFnXCI6XG4gICAgICAgICAgICBjdXN0b20gPSBldnQub2xkSW5kaWNpZXMubWFwKChjdXJyLCBpbmRleCk9Pih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGN1cnIubXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXg6IGN1cnIuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4OiBldnQubmV3SW5kaWNpZXNbaW5kZXhdLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi8gY29uc3QgY3VzdG9tcyA9ICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCRiYzA2YTNhZjdkYzY1ZjUzKGN1c3RvbSwgbGlzdCk7XG4gICAgcmV0dXJuIGN1c3RvbXM7XG59XG5mdW5jdGlvbiAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkYzI1Y2Y4MDgwYmQzMDVlYyhub3JtYWxpemVkLCBsaXN0KSB7XG4gICAgY29uc3QgYSA9ICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCRiZTJkYTk1ZTYxNjdiMGJkKG5vcm1hbGl6ZWQsIGxpc3QpO1xuICAgIGNvbnN0IGIgPSAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkZWNhODUxZWU2NWFlMTdlNChub3JtYWxpemVkLCBhKTtcbiAgICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCRiZTJkYTk1ZTYxNjdiMGJkKG5vcm1hbGl6ZWQsIGxpc3QpIHtcbiAgICBjb25zdCBuZXdMaXN0ID0gW1xuICAgICAgICAuLi5saXN0XG4gICAgXTtcbiAgICBub3JtYWxpemVkLmNvbmNhdCgpLnJldmVyc2UoKS5mb3JFYWNoKChjdXJyKT0+bmV3TGlzdC5zcGxpY2UoY3Vyci5vbGRJbmRleCwgMSkpO1xuICAgIHJldHVybiBuZXdMaXN0O1xufVxuZnVuY3Rpb24gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JGVjYTg1MWVlNjVhZTE3ZTQobm9ybWFsaXplZCwgbGlzdCwgZXZ0LCBjbG9uZSkge1xuICAgIGNvbnN0IG5ld0xpc3QgPSBbXG4gICAgICAgIC4uLmxpc3RcbiAgICBdO1xuICAgIG5vcm1hbGl6ZWQuZm9yRWFjaCgoY3Vycik9PntcbiAgICAgICAgY29uc3QgbmV3SXRlbSA9IGNsb25lICYmIGV2dCAmJiBjbG9uZShjdXJyLml0ZW0sIGV2dCk7XG4gICAgICAgIG5ld0xpc3Quc3BsaWNlKGN1cnIubmV3SW5kZXgsIDAsIG5ld0l0ZW0gfHwgY3Vyci5pdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3TGlzdDtcbn1cbmZ1bmN0aW9uICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCQxZmMwZjYyMDU4MjllMTljKGV2dCkge1xuICAgIGlmIChldnQub2xkSW5kaWNpZXMgJiYgZXZ0Lm9sZEluZGljaWVzLmxlbmd0aCA+IDApIHJldHVybiBcIm11bHRpZHJhZ1wiO1xuICAgIGlmIChldnQuc3dhcEl0ZW0pIHJldHVybiBcInN3YXBcIjtcbiAgICByZXR1cm4gXCJub3JtYWxcIjtcbn1cbmZ1bmN0aW9uICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCRiYzA2YTNhZjdkYzY1ZjUzKGlucHV0cywgbGlzdCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpbnB1dHMubWFwKChjdXJyKT0+KHtcbiAgICAgICAgICAgIC4uLmN1cnIsXG4gICAgICAgICAgICBpdGVtOiBsaXN0W2N1cnIub2xkSW5kZXhdXG4gICAgICAgIH0pKS5zb3J0KChhLCBiKT0+YS5vbGRJbmRleCAtIGIub2xkSW5kZXgpO1xuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDc1NTNjODFlNjJlMzFiN2UocHJvcHMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqLyBjb25zdCB7IGxpc3Q6IC8vIHJlYWN0IHNvcnRhYmxlIHByb3BzXG4gICAgbGlzdCAsIHNldExpc3Q6IHNldExpc3QgLCBjaGlsZHJlbjogY2hpbGRyZW4gLCB0YWc6IHRhZyAsIHN0eWxlOiBzdHlsZSAsIGNsYXNzTmFtZTogY2xhc3NOYW1lICwgY2xvbmU6IGNsb25lICwgb25BZGQ6IC8vIHNvcnRhYmxlIG9wdGlvbnMgdGhhdCBoYXZlIG1ldGhvZHMgd2Ugd2FudCB0byBvdmVyd3JpdGVcbiAgICBvbkFkZCAsIG9uQ2hhbmdlOiBvbkNoYW5nZSAsIG9uQ2hvb3NlOiBvbkNob29zZSAsIG9uQ2xvbmU6IG9uQ2xvbmUgLCBvbkVuZDogb25FbmQgLCBvbkZpbHRlcjogb25GaWx0ZXIgLCBvblJlbW92ZTogb25SZW1vdmUgLCBvblNvcnQ6IG9uU29ydCAsIG9uU3RhcnQ6IG9uU3RhcnQgLCBvblVuY2hvb3NlOiBvblVuY2hvb3NlICwgb25VcGRhdGU6IG9uVXBkYXRlICwgb25Nb3ZlOiBvbk1vdmUgLCBvblNwaWxsOiBvblNwaWxsICwgb25TZWxlY3Q6IG9uU2VsZWN0ICwgb25EZXNlbGVjdDogb25EZXNlbGVjdCAsIC4uLm9wdGlvbnMgfSA9IHByb3BzO1xuICAgIC8qIGVzbGludC1lbmFibGUgKi8gcmV0dXJuIG9wdGlvbnM7XG59XG5cblxuLyoqIEhvbGRzIGEgZ2xvYmFsIHJlZmVyZW5jZSBmb3Igd2hpY2ggcmVhY3QgZWxlbWVudCBpcyBiZWluZyBkcmFnZ2VkICovIC8vIEB0b2RvIC0gdXNlIGNvbnRleHQgdG8gbWFuYWdlIHRoaXMuIEhvdyBkb2VzIG9uZSB1c2UgMiBkaWZmZXJlbnQgcHJvdmlkZXJzP1xuY29uc3QgJDdmZThlM2VhNTcyYmRhN2EkdmFyJHN0b3JlID0ge1xuICAgIGRyYWdnaW5nOiBudWxsXG59O1xuY2xhc3MgJDdmZThlM2VhNTcyYmRhN2EkZXhwb3J0JDExYmJlZDllZTAwMTJjMTMgZXh0ZW5kcyAoMCwgJDh6SFVvJHJlYWN0LkNvbXBvbmVudCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqLyBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjbG9uZTogKGl0ZW0pPT5pdGVtXG4gICAgfTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgLy8gQHRvZG8gZm9yd2FyZCByZWYgdGhpcyBjb21wb25lbnRcbiAgICAgICAgdGhpcy5yZWYgPSAvKiNfX1BVUkVfXyovICgwLCAkOHpIVW8kcmVhY3QuY3JlYXRlUmVmKSgpO1xuICAgICAgICAvLyBtYWtlIGFsbCBzdGF0ZSBmYWxzZSBiZWNhdXNlIHdlIGNhbid0IGNoYW5nZSBzb3J0YWJsZSB1bmxlc3MgYSBtb3VzZSBnZXN0dXJlIGlzIG1hZGUuXG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSBbXG4gICAgICAgICAgICAuLi5wcm9wcy5saXN0XG4gICAgICAgIF0ubWFwKChpdGVtKT0+T2JqZWN0LmFzc2lnbihpdGVtLCB7XG4gICAgICAgICAgICAgICAgY2hvc2VuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgcHJvcHMuc2V0TGlzdChuZXdMaXN0LCB0aGlzLnNvcnRhYmxlLCAkN2ZlOGUzZWE1NzJiZGE3YSR2YXIkc3RvcmUpO1xuICAgICAgICAoMCwgKCRwYXJjZWwkaW50ZXJvcERlZmF1bHQoJDh6SFVvJHRpbnlpbnZhcmlhbnQpKSkoLy9AdHMtZXhwZWN0LWVycm9yOiBEb2Vzbid0IGV4aXN0LiBXaWxsIGRlcHJlY2F0ZSBzb29uLlxuICAgICAgICAhcHJvcHMucGx1Z2lucywgYFxuUGx1Z2lucyBwcm9wIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG5JbnN0ZWFkLCBtb3VudCBpdCB3aXRoIFwiU29ydGFibGUubW91bnQobmV3IE11bHRpRHJhZygpKVwiXG5QbGVhc2UgcmVhZCB0aGUgdXBkYXRlZCBSRUFETUUubWQgYXQgaHR0cHM6Ly9naXRodWIuY29tL1NvcnRhYmxlSlMvcmVhY3Qtc29ydGFibGVqcy5cbiAgICAgIGApO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmLmN1cnJlbnQgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHRoaXMubWFrZU9wdGlvbnMoKTtcbiAgICAgICAgKDAsICgkcGFyY2VsJGludGVyb3BEZWZhdWx0KCQ4ekhVbyRzb3J0YWJsZWpzKSkpLmNyZWF0ZSh0aGlzLnJlZi5jdXJyZW50LCBuZXdPcHRpb25zKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLmRpc2FibGVkICE9PSB0aGlzLnByb3BzLmRpc2FibGVkICYmIHRoaXMuc29ydGFibGUpIHRoaXMuc29ydGFibGUub3B0aW9uKFwiZGlzYWJsZWRcIiwgdGhpcy5wcm9wcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyB0YWc6IHRhZyAsIHN0eWxlOiBzdHlsZSAsIGNsYXNzTmFtZTogY2xhc3NOYW1lICwgaWQ6IGlkICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY2xhc3NpY1Byb3BzID0ge1xuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgbm8gdGFnLCBkZWZhdWx0IHRvIGEgYGRpdmAgZWxlbWVudC5cbiAgICAgICAgY29uc3QgbmV3VGFnID0gIXRhZyB8fCB0YWcgPT09IG51bGwgPyBcImRpdlwiIDogdGFnO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDh6SFVvJHJlYWN0LmNyZWF0ZUVsZW1lbnQpKG5ld1RhZywge1xuICAgICAgICAgICAgLy8gQHRvZG8gLSBmaW5kIGEgd2F5IChwZXJoYXBzIHdpdGggdGhlIGNhbGxiYWNrKSB0byBhbGxvdyBBbnREIGNvbXBvbmVudHMgdG8gd29ya1xuICAgICAgICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgICAgICAgIC4uLmNsYXNzaWNQcm9wc1xuICAgICAgICB9LCB0aGlzLmdldENoaWxkcmVuKCkpO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogY2hpbGRyZW4gLCBkYXRhSWRBdHRyOiBkYXRhSWRBdHRyICwgc2VsZWN0ZWRDbGFzczogc2VsZWN0ZWRDbGFzcyA9IFwic29ydGFibGUtc2VsZWN0ZWRcIiAsIGNob3NlbkNsYXNzOiBjaG9zZW5DbGFzcyA9IFwic29ydGFibGUtY2hvc2VuXCIgLCBkcmFnQ2xhc3M6IC8qIGVzbGludC1kaXNhYmxlICovIGRyYWdDbGFzcyA9IFwic29ydGFibGUtZHJhZ1wiICwgZmFsbGJhY2tDbGFzczogZmFsbGJhY2tDbGFzcyA9IFwic29ydGFibGUtZmFsYmFja1wiICwgZ2hvc3RDbGFzczogZ2hvc3RDbGFzcyA9IFwic29ydGFibGUtZ2hvc3RcIiAsIHN3YXBDbGFzczogc3dhcENsYXNzID0gXCJzb3J0YWJsZS1zd2FwLWhpZ2hsaWdodFwiICwgZmlsdGVyOiAvKiBlc2xpbnQtZW5hYmxlICovIGZpbHRlciA9IFwic29ydGFibGUtZmlsdGVyXCIgLCBsaXN0OiBsaXN0ICwgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAvLyBpZiBubyBjaGlsZHJlbiwgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgIGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGRhdGFpZCA9IGRhdGFJZEF0dHIgfHwgXCJkYXRhLWlkXCI7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqLyByZXR1cm4gKDAsICQ4ekhVbyRyZWFjdC5DaGlsZHJlbikubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGluZGV4KT0+e1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpbmRleF0gfHwge307XG4gICAgICAgICAgICBjb25zdCB7IGNsYXNzTmFtZTogcHJldkNsYXNzTmFtZSAgfSA9IGNoaWxkLnByb3BzO1xuICAgICAgICAgICAgLy8gQHRvZG8gLSBoYW5kbGUgdGhlIGZ1bmN0aW9uIGlmIGF2YWxhYmxlLiBJIGRvbid0IHRoaW5rIGFueW9uZSB3aWxsIGJlIGRvaW5nIHRoaXMgc29vbi5cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gdHlwZW9mIGZpbHRlciA9PT0gXCJzdHJpbmdcIiAmJiB7XG4gICAgICAgICAgICAgICAgW2ZpbHRlci5yZXBsYWNlKFwiLlwiLCBcIlwiKV06ICEhaXRlbS5maWx0ZXJlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9ICgwLCAoJHBhcmNlbCRpbnRlcm9wRGVmYXVsdCgkOHpIVW8kY2xhc3NuYW1lcykpKShwcmV2Q2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAgICAgW3NlbGVjdGVkQ2xhc3NdOiBpdGVtLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIFtjaG9zZW5DbGFzc106IGl0ZW0uY2hvc2VuLFxuICAgICAgICAgICAgICAgIC4uLmZpbHRlcmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkOHpIVW8kcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwge1xuICAgICAgICAgICAgICAgIFtkYXRhaWRdOiBjaGlsZC5rZXksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEFwcGVuZHMgdGhlIGBzb3J0YWJsZWAgcHJvcGVydHkgdG8gdGhpcyBjb21wb25lbnQgKi8gZ2V0IHNvcnRhYmxlKCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKGVsKS5maW5kKChrKT0+ay5pbmNsdWRlcyhcIlNvcnRhYmxlXCIpKTtcbiAgICAgICAgaWYgKCFrZXkpIHJldHVybiBudWxsO1xuICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3I6IGZpeCBtZS5cbiAgICAgICAgcmV0dXJuIGVsW2tleV07XG4gICAgfVxuICAgIC8qKiBDb252ZXJ0cyBhbGwgdGhlIHByb3BzIGZyb20gYFJlYWN0U29ydGFibGVgIGludG8gdGhlIGBvcHRpb25zYCBvYmplY3QgdGhhdCBgU29ydGFibGUuY3JlYXRlKGVsLCBbb3B0aW9uc10pYCBjYW4gdXNlLiAqLyBtYWtlT3B0aW9ucygpIHtcbiAgICAgICAgY29uc3QgRE9NSGFuZGxlcnMgPSBbXG4gICAgICAgICAgICBcIm9uQWRkXCIsXG4gICAgICAgICAgICBcIm9uQ2hvb3NlXCIsXG4gICAgICAgICAgICBcIm9uRGVzZWxlY3RcIixcbiAgICAgICAgICAgIFwib25FbmRcIixcbiAgICAgICAgICAgIFwib25SZW1vdmVcIixcbiAgICAgICAgICAgIFwib25TZWxlY3RcIixcbiAgICAgICAgICAgIFwib25TcGlsbFwiLFxuICAgICAgICAgICAgXCJvblN0YXJ0XCIsXG4gICAgICAgICAgICBcIm9uVW5jaG9vc2VcIixcbiAgICAgICAgICAgIFwib25VcGRhdGVcIiwgXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IE5vbkRPTUhhbmRsZXJzID0gW1xuICAgICAgICAgICAgXCJvbkNoYW5nZVwiLFxuICAgICAgICAgICAgXCJvbkNsb25lXCIsXG4gICAgICAgICAgICBcIm9uRmlsdGVyXCIsXG4gICAgICAgICAgICBcIm9uU29ydFwiLCBcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9ICgwLCAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkNzU1M2M4MWU2MmUzMWI3ZSkodGhpcy5wcm9wcyk7XG4gICAgICAgIERPTUhhbmRsZXJzLmZvckVhY2goKG5hbWUpPT5uZXdPcHRpb25zW25hbWVdID0gdGhpcy5wcmVwYXJlT25IYW5kbGVyUHJvcEFuZERPTShuYW1lKSk7XG4gICAgICAgIE5vbkRPTUhhbmRsZXJzLmZvckVhY2goKG5hbWUpPT5uZXdPcHRpb25zW25hbWVdID0gdGhpcy5wcmVwYXJlT25IYW5kbGVyUHJvcChuYW1lKSk7XG4gICAgICAgIC8qKiBvbk1vdmUgaGFzIDIgYXJndW1lbnRzIGFuZCBuZWVkcyB0byBiZSBoYW5kbGVkIHNlcGVyYXRlbHkuICovIGNvbnN0IG9uTW92ZTEgPSAoZXZ0LCBvcmlnaW5hbEV2dCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgb25Nb3ZlOiBvbk1vdmUgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZXZ0LndpbGxJbnNlcnRBZnRlciB8fCAtMTtcbiAgICAgICAgICAgIGlmICghb25Nb3ZlKSByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb25Nb3ZlKGV2dCwgb3JpZ2luYWxFdnQsIHRoaXMuc29ydGFibGUsICQ3ZmU4ZTNlYTU3MmJkYTdhJHZhciRzdG9yZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld09wdGlvbnMsXG4gICAgICAgICAgICBvbk1vdmU6IG9uTW92ZTFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFByZXBhcmVzIGEgbWV0aG9kIHRoYXQgd2lsbCBiZSB1c2VkIGluIHRoZSBzb3J0YWJsZSBvcHRpb25zIHRvIGNhbGwgYW4gYG9uW0hhbmRsZXJdYCBwcm9wICYgYW4gYG9uW0hhbmRsZXJdYCBSZWFjdFNvcnRhYmxlIG1ldGhvZC4gICovIHByZXBhcmVPbkhhbmRsZXJQcm9wQW5kRE9NKGV2dE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChldnQpPT57XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBjb21wb25lbnQgcHJvcFxuICAgICAgICAgICAgdGhpcy5jYWxsT25IYW5kbGVyUHJvcChldnQsIGV2dE5hbWUpO1xuICAgICAgICAgICAgLy8gY2FsbHMgc3RhdGUgY2hhbmdlXG4gICAgICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3I6IHVudGlsIEB0eXBlcyBtdWx0aWRyYWcgaXRlbSBpcyBpblxuICAgICAgICAgICAgdGhpc1tldnROYW1lXShldnQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogUHJlcGFyZXMgYSBtZXRob2QgdGhhdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHNvcnRhYmxlIG9wdGlvbnMgdG8gY2FsbCBhbiBgb25bSGFuZGxlcl1gIHByb3AgKi8gcHJlcGFyZU9uSGFuZGxlclByb3AoZXZ0TmFtZSkge1xuICAgICAgICByZXR1cm4gKGV2dCk9PntcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGNvbXBvbmVudCBwcm9wXG4gICAgICAgICAgICB0aGlzLmNhbGxPbkhhbmRsZXJQcm9wKGV2dCwgZXZ0TmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBDYWxscyB0aGUgYHByb3BzLm9uW0hhbmRsZXJdYCBmdW5jdGlvbiAqLyBjYWxsT25IYW5kbGVyUHJvcChldnQsIGV2dE5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvcEV2ZW50ID0gdGhpcy5wcm9wc1tldnROYW1lXTtcbiAgICAgICAgaWYgKHByb3BFdmVudCkgcHJvcEV2ZW50KGV2dCwgdGhpcy5zb3J0YWJsZSwgJDdmZThlM2VhNTcyYmRhN2EkdmFyJHN0b3JlKTtcbiAgICB9XG4gICAgLy8gU09SVEFCTEUgRE9NIEhBTkRMSU5HXG4gICAgb25BZGQoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdDogbGlzdCAsIHNldExpc3Q6IHNldExpc3QgLCBjbG9uZTogY2xvbmUgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi8gY29uc3Qgb3RoZXJMaXN0ID0gW1xuICAgICAgICAgICAgLi4uJDdmZThlM2VhNTcyYmRhN2EkdmFyJHN0b3JlLmRyYWdnaW5nLnByb3BzLmxpc3RcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgY3VzdG9tcyA9ICgwLCAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkNDY1NWVmZTcwMGY4ODdhKShldnQsIG90aGVyTGlzdCk7XG4gICAgICAgICgwLCAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkNzdmNDlhMjU2MDIxYzhkZSkoY3VzdG9tcyk7XG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSAoMCwgJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JGVjYTg1MWVlNjVhZTE3ZTQpKGN1c3RvbXMsIGxpc3QsIGV2dCwgY2xvbmUpLm1hcCgoaXRlbSk9Pk9iamVjdC5hc3NpZ24oaXRlbSwge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICBzZXRMaXN0KG5ld0xpc3QsIHRoaXMuc29ydGFibGUsICQ3ZmU4ZTNlYTU3MmJkYTdhJHZhciRzdG9yZSk7XG4gICAgfVxuICAgIG9uUmVtb3ZlKGV2dCkge1xuICAgICAgICBjb25zdCB7IGxpc3Q6IGxpc3QgLCBzZXRMaXN0OiBzZXRMaXN0ICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbW9kZSA9ICgwLCAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkMWZjMGY2MjA1ODI5ZTE5YykoZXZ0KTtcbiAgICAgICAgY29uc3QgY3VzdG9tcyA9ICgwLCAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkNDY1NWVmZTcwMGY4ODdhKShldnQsIGxpc3QpO1xuICAgICAgICAoMCwgJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JGE2MTc3ZDU4MjlmNzBlYmMpKGN1c3RvbXMpO1xuICAgICAgICBsZXQgbmV3TGlzdCA9IFtcbiAgICAgICAgICAgIC4uLmxpc3RcbiAgICAgICAgXTtcbiAgICAgICAgLy8gcmVtb3ZlIHN0YXRlIGlmIG5vdCBpbiBjbG9uZSBtb2RlLiBvdGhlcndpc2UsIGtlZXAuXG4gICAgICAgIGlmIChldnQucHVsbE1vZGUgIT09IFwiY2xvbmVcIikgbmV3TGlzdCA9ICgwLCAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkYmUyZGE5NWU2MTY3YjBiZCkoY3VzdG9tcywgbmV3TGlzdCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3dpdGNoIHVzZWQgdG8gZ2V0IHRoZSBjbG9uZVxuICAgICAgICAgICAgbGV0IGN1c3RvbUNsb25lcyA9IGN1c3RvbXM7XG4gICAgICAgICAgICBzd2l0Y2gobW9kZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm11bHRpZHJhZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjdXN0b21DbG9uZXMgPSBjdXN0b21zLm1hcCgoaXRlbSwgaW5kZXgpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZXZ0LmNsb25lc1tpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgICAgICAgICAgICAgICBjdXN0b21DbG9uZXMgPSBjdXN0b21zLm1hcCgoaXRlbSk9Pih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBldnQuY2xvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN3YXBcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAoMCwgKCRwYXJjZWwkaW50ZXJvcERlZmF1bHQoJDh6SFVvJHRpbnlpbnZhcmlhbnQpKSkodHJ1ZSwgYG1vZGUgXCIke21vZGV9XCIgY2Fubm90IGNsb25lLiBQbGVhc2UgcmVtb3ZlIFwicHJvcHMuY2xvbmVcIiBmcm9tIDxSZWFjdFNvcnRhYmxlLz4gd2hlbiB1c2luZyB0aGUgXCIke21vZGV9XCIgcGx1Z2luYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDc3ZjQ5YTI1NjAyMWM4ZGUpKGN1c3RvbUNsb25lcyk7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHNlbGVjdGVkIGl0ZW1zIHdpdGggY2xvbmVkIGl0ZW1zXG4gICAgICAgICAgICBjdXN0b21zLmZvckVhY2goKGN1cnIpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyLm9sZEluZGV4O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqLyBjb25zdCBuZXdJdGVtID0gdGhpcy5wcm9wcy5jbG9uZShjdXJyLml0ZW0sIGV2dCk7XG4gICAgICAgICAgICAgICAgbmV3TGlzdC5zcGxpY2UoaW5kZXgsIDEsIG5ld0l0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGl0ZW0uc2VsZWN0ZWQgZnJvbSBsaXN0XG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0Lm1hcCgoaXRlbSk9Pk9iamVjdC5hc3NpZ24oaXRlbSwge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICBzZXRMaXN0KG5ld0xpc3QsIHRoaXMuc29ydGFibGUsICQ3ZmU4ZTNlYTU3MmJkYTdhJHZhciRzdG9yZSk7XG4gICAgfVxuICAgIG9uVXBkYXRlKGV2dCkge1xuICAgICAgICBjb25zdCB7IGxpc3Q6IGxpc3QgLCBzZXRMaXN0OiBzZXRMaXN0ICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY3VzdG9tcyA9ICgwLCAkZWIwM2U3NGY4ZjdkYjFmMyRleHBvcnQkNDY1NWVmZTcwMGY4ODdhKShldnQsIGxpc3QpO1xuICAgICAgICAoMCwgJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDc3ZjQ5YTI1NjAyMWM4ZGUpKGN1c3RvbXMpO1xuICAgICAgICAoMCwgJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JGE2MTc3ZDU4MjlmNzBlYmMpKGN1c3RvbXMpO1xuICAgICAgICBjb25zdCBuZXdMaXN0ID0gKDAsICRlYjAzZTc0ZjhmN2RiMWYzJGV4cG9ydCRjMjVjZjgwODBiZDMwNWVjKShjdXN0b21zLCBsaXN0KTtcbiAgICAgICAgcmV0dXJuIHNldExpc3QobmV3TGlzdCwgdGhpcy5zb3J0YWJsZSwgJDdmZThlM2VhNTcyYmRhN2EkdmFyJHN0b3JlKTtcbiAgICB9XG4gICAgb25TdGFydCgpIHtcbiAgICAgICAgJDdmZThlM2VhNTcyYmRhN2EkdmFyJHN0b3JlLmRyYWdnaW5nID0gdGhpcztcbiAgICB9XG4gICAgb25FbmQoKSB7XG4gICAgICAgICQ3ZmU4ZTNlYTU3MmJkYTdhJHZhciRzdG9yZS5kcmFnZ2luZyA9IG51bGw7XG4gICAgfVxuICAgIG9uQ2hvb3NlKGV2dCkge1xuICAgICAgICBjb25zdCB7IGxpc3Q6IGxpc3QgLCBzZXRMaXN0OiBzZXRMaXN0ICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbmV3TGlzdCA9IGxpc3QubWFwKChpdGVtLCBpbmRleCk9PntcbiAgICAgICAgICAgIGxldCBuZXdJdGVtID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZXZ0Lm9sZEluZGV4KSBuZXdJdGVtID0gT2JqZWN0LmFzc2lnbihpdGVtLCB7XG4gICAgICAgICAgICAgICAgY2hvc2VuOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdJdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0TGlzdChuZXdMaXN0LCB0aGlzLnNvcnRhYmxlLCAkN2ZlOGUzZWE1NzJiZGE3YSR2YXIkc3RvcmUpO1xuICAgIH1cbiAgICBvblVuY2hvb3NlKGV2dCkge1xuICAgICAgICBjb25zdCB7IGxpc3Q6IGxpc3QgLCBzZXRMaXN0OiBzZXRMaXN0ICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbmV3TGlzdCA9IGxpc3QubWFwKChpdGVtLCBpbmRleCk9PntcbiAgICAgICAgICAgIGxldCBuZXdJdGVtID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZXZ0Lm9sZEluZGV4KSBuZXdJdGVtID0gT2JqZWN0LmFzc2lnbihuZXdJdGVtLCB7XG4gICAgICAgICAgICAgICAgY2hvc2VuOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3SXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldExpc3QobmV3TGlzdCwgdGhpcy5zb3J0YWJsZSwgJDdmZThlM2VhNTcyYmRhN2EkdmFyJHN0b3JlKTtcbiAgICB9XG4gICAgb25TcGlsbChldnQpIHtcbiAgICAgICAgY29uc3QgeyByZW1vdmVPblNwaWxsOiByZW1vdmVPblNwaWxsICwgcmV2ZXJ0T25TcGlsbDogcmV2ZXJ0T25TcGlsbCAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChyZW1vdmVPblNwaWxsICYmICFyZXZlcnRPblNwaWxsKSAoMCwgJGViMDNlNzRmOGY3ZGIxZjMkZXhwb3J0JDFkMGFhMTYwNDMyZGZlYTUpKGV2dC5pdGVtKTtcbiAgICB9XG4gICAgb25TZWxlY3QoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdDogbGlzdCAsIHNldExpc3Q6IHNldExpc3QgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBuZXdMaXN0ID0gbGlzdC5tYXAoKGl0ZW0pPT5PYmplY3QuYXNzaWduKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgZXZ0Lm5ld0luZGljaWVzLmZvckVhY2goKGN1cnIpPT57XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnIuaW5kZXg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFwiJHtldnQudHlwZX1cIiBoYWQgaW5kaWNlIG9mIFwiJHtjdXJyLmluZGV4fVwiLCB3aGljaCBpcyBwcm9iYWJseSAtMSBhbmQgZG9lc24ndCB1c3VhbGx5IGhhcHBlbiBoZXJlLmApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3TGlzdFtpbmRleF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0TGlzdChuZXdMaXN0LCB0aGlzLnNvcnRhYmxlLCAkN2ZlOGUzZWE1NzJiZGE3YSR2YXIkc3RvcmUpO1xuICAgIH1cbiAgICBvbkRlc2VsZWN0KGV2dCkge1xuICAgICAgICBjb25zdCB7IGxpc3Q6IGxpc3QgLCBzZXRMaXN0OiBzZXRMaXN0ICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbmV3TGlzdCA9IGxpc3QubWFwKChpdGVtKT0+T2JqZWN0LmFzc2lnbihpdGVtLCB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIGV2dC5uZXdJbmRpY2llcy5mb3JFYWNoKChjdXJyKT0+e1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyLmluZGV4O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICAgICAgICAgICAgbmV3TGlzdFtpbmRleF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0TGlzdChuZXdMaXN0LCB0aGlzLnNvcnRhYmxlLCAkN2ZlOGUzZWE1NzJiZGE3YSR2YXIkc3RvcmUpO1xuICAgIH1cbn1cblxuXG52YXIgJGZhZWZhYWQ5NWU1ZmNjYTAkZXhwb3J0cyA9IHt9O1xuXG5cbiRwYXJjZWwkZXhwb3J0V2lsZGNhcmQobW9kdWxlLmV4cG9ydHMsICRmYWVmYWFkOTVlNWZjY2EwJGV4cG9ydHMpO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-sortablejs/dist/index.js\n");

/***/ })

};
;